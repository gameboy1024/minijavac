{"filter":false,"title":"Compilation.ml","tooltip":"/Compilation/Compilation.ml","undoManager":{"mark":1,"position":1,"stack":[[{"group":"doc","deltas":[{"start":{"row":0,"column":0},"end":{"row":116,"column":34},"action":"insert","lines":["open Hashtbl","open Structure","open TypedStructure","open CompileStructures","(* Build the classes descriptors of the primitive classes. *)","let build_basic_classes_descriptors classes_descriptors =","Hashtbl.add classes_descriptors \"Object\" ObjectClass;","Hashtbl.add classes_descriptors \"Int\" IntClass;","Hashtbl.add classes_descriptors \"Boolean\" BooleanClass;","Hashtbl.add classes_descriptors \"String\" StringClass","let add_heritage_structures classes_descriptors methods_table =","let (table_done: (string, bool) Hashtbl.t) = Hashtbl.create 10","in let merge_attrs parent_desc class_desc =","match parent_desc with","| ClassDescriptor cd ->","Hashtbl.iter","(fun k (v: attribute_descriptor) -> if v.static then () else Hashtbl.add class_desc.attributes k v)","cd.attributes","| _ -> ()","and merge_methods parent_desc class_desc =","let add_method m_short_id m_id =","try","Hashtbl.find class_desc.methods m_short_id;","()","(* Found, don't add the parent method definition *)","with Not_found ->","(* Not found, so the parent's definition must be added *)","Hashtbl.add class_desc.methods m_short_id m_id","in match parent_desc with","| ClassDescriptor cd -> Hashtbl.iter add_method cd.methods","| _ -> ()","in let add_heritage_structure class_name class_descriptor =","match class_descriptor with","| ClassDescriptor cd ->","if Hashtbl.find table_done class_name <> true then begin","let parent_descriptor = Hashtbl.find classes_descriptors cd.parent","in","Hashtbl.replace table_done cd.name true;","merge_attrs parent_descriptor cd;","merge_methods parent_descriptor cd","end","(* The descriptor for that class has already been checked, return it as is. *)","| _ -> ()","in","Hashtbl.iter (fun k _ -> Hashtbl.add table_done k false) classes_descriptors;","Hashtbl.iter add_heritage_structure classes_descriptors","(* This function builds the methods and attributes descriptors of a class *)","(* class_descriptor is the class descriptor to which we add attributs and methods descriptors. *)","(* methods_table is the global methods' table. *)","(* l_methods_attrs is the list of typed methods and attributs defined in the class. *)","(* This function returns Unit, since it only modifies the two first parameters. *)","let rec build_attrs_and_methods_descriptors class_descriptor methods_table l_methods_attrs =","let _add_method_to_descriptor m =","(* Build a method descriptor and add it to the global methods table. Also, add a link to the method","in the list of methods of the current class descriptor. It returns Unit *)","let build_method_descriptor m_name args m_expr m_static =","let m_short_id = build_short_method_identifier m_name (params_types args)","in let m_id = class_descriptor.name ^ \"[\" ^ m_short_id ^ \"]\"","in","Hashtbl.add methods_table m_id","{","static=m_static;","core=m_expr;","args_names=params_names args;","};","Hashtbl.add class_descriptor.methods m_short_id m_id","in match Located.elem_of m with","| TypedMethod(r, n, args, e, t) -> build_method_descriptor (Located.elem_of n) args e false","| TypedStaticMethod(r, n, args, e, t) -> build_method_descriptor (Located.elem_of n) args e true","and _add_attr_to_descriptor n static e =","Hashtbl.add class_descriptor.attributes (Located.elem_of n) {default=e; static=static;}","in match l_methods_attrs with","| [] -> ()","| elem::q -> (match (Located.elem_of elem) with","| TypedMethod _ | TypedStaticMethod _ -> _add_method_to_descriptor elem;","| TypedAttr(_, n, t) -> _add_attr_to_descriptor n false (Located.mk_elem TypedNull (Located.loc_of elem))","| TypedAttrWithValue(_, n, e, t) -> _add_attr_to_descriptor n false e","| TypedStaticAttr(_, n, t) -> _add_attr_to_descriptor n true (Located.mk_elem TypedNull (Located.loc_of elem))","| TypedStaticAttrWithValue(_, n, e, t) -> _add_attr_to_descriptor n true e",");","build_attrs_and_methods_descriptors class_descriptor methods_table q","(* Create new classes descriptors, but without methods and attributes for the moment. *)","let rec build_descriptors_1 classes_descriptors methods_table tree =","match tree with","| [] -> ()","| t::q -> (match Located.elem_of t with","| TypedClassdef (n, l) ->","let adv_class_descriptor = {","name=Located.elem_of n;","parent=\"Object\";","attributes=Hashtbl.create 10;","methods=Hashtbl.create 10;","}","in","Hashtbl.add classes_descriptors (Located.elem_of n) (ClassDescriptor(adv_class_descriptor));","build_attrs_and_methods_descriptors adv_class_descriptor methods_table l","| TypedClassdefWithParent (n, p, l) ->","let adv_class_descriptor = {","name=Located.elem_of n;","parent=string_of_classname (Located.elem_of p);","attributes=Hashtbl.create 10;","methods=Hashtbl.create 10;","}","in","Hashtbl.add classes_descriptors (Located.elem_of n) (ClassDescriptor(adv_class_descriptor));","build_attrs_and_methods_descriptors adv_class_descriptor methods_table l","| _ -> ()",");","build_descriptors_1 classes_descriptors methods_table q","let compile tree =","let classes_descriptors = Hashtbl.create 10","and methods_table = Hashtbl.create 30","in","build_basic_classes_descriptors classes_descriptors;","build_descriptors_1 classes_descriptors methods_table tree;","add_heritage_structures classes_descriptors methods_table;","classes_descriptors, methods_table"]}]}],[{"group":"doc","deltas":[{"start":{"row":0,"column":0},"end":{"row":116,"column":34},"action":"remove","lines":["open Hashtbl","open Structure","open TypedStructure","open CompileStructures","(* Build the classes descriptors of the primitive classes. *)","let build_basic_classes_descriptors classes_descriptors =","Hashtbl.add classes_descriptors \"Object\" ObjectClass;","Hashtbl.add classes_descriptors \"Int\" IntClass;","Hashtbl.add classes_descriptors \"Boolean\" BooleanClass;","Hashtbl.add classes_descriptors \"String\" StringClass","let add_heritage_structures classes_descriptors methods_table =","let (table_done: (string, bool) Hashtbl.t) = Hashtbl.create 10","in let merge_attrs parent_desc class_desc =","match parent_desc with","| ClassDescriptor cd ->","Hashtbl.iter","(fun k (v: attribute_descriptor) -> if v.static then () else Hashtbl.add class_desc.attributes k v)","cd.attributes","| _ -> ()","and merge_methods parent_desc class_desc =","let add_method m_short_id m_id =","try","Hashtbl.find class_desc.methods m_short_id;","()","(* Found, don't add the parent method definition *)","with Not_found ->","(* Not found, so the parent's definition must be added *)","Hashtbl.add class_desc.methods m_short_id m_id","in match parent_desc with","| ClassDescriptor cd -> Hashtbl.iter add_method cd.methods","| _ -> ()","in let add_heritage_structure class_name class_descriptor =","match class_descriptor with","| ClassDescriptor cd ->","if Hashtbl.find table_done class_name <> true then begin","let parent_descriptor = Hashtbl.find classes_descriptors cd.parent","in","Hashtbl.replace table_done cd.name true;","merge_attrs parent_descriptor cd;","merge_methods parent_descriptor cd","end","(* The descriptor for that class has already been checked, return it as is. *)","| _ -> ()","in","Hashtbl.iter (fun k _ -> Hashtbl.add table_done k false) classes_descriptors;","Hashtbl.iter add_heritage_structure classes_descriptors","(* This function builds the methods and attributes descriptors of a class *)","(* class_descriptor is the class descriptor to which we add attributs and methods descriptors. *)","(* methods_table is the global methods' table. *)","(* l_methods_attrs is the list of typed methods and attributs defined in the class. *)","(* This function returns Unit, since it only modifies the two first parameters. *)","let rec build_attrs_and_methods_descriptors class_descriptor methods_table l_methods_attrs =","let _add_method_to_descriptor m =","(* Build a method descriptor and add it to the global methods table. Also, add a link to the method","in the list of methods of the current class descriptor. It returns Unit *)","let build_method_descriptor m_name args m_expr m_static =","let m_short_id = build_short_method_identifier m_name (params_types args)","in let m_id = class_descriptor.name ^ \"[\" ^ m_short_id ^ \"]\"","in","Hashtbl.add methods_table m_id","{","static=m_static;","core=m_expr;","args_names=params_names args;","};","Hashtbl.add class_descriptor.methods m_short_id m_id","in match Located.elem_of m with","| TypedMethod(r, n, args, e, t) -> build_method_descriptor (Located.elem_of n) args e false","| TypedStaticMethod(r, n, args, e, t) -> build_method_descriptor (Located.elem_of n) args e true","and _add_attr_to_descriptor n static e =","Hashtbl.add class_descriptor.attributes (Located.elem_of n) {default=e; static=static;}","in match l_methods_attrs with","| [] -> ()","| elem::q -> (match (Located.elem_of elem) with","| TypedMethod _ | TypedStaticMethod _ -> _add_method_to_descriptor elem;","| TypedAttr(_, n, t) -> _add_attr_to_descriptor n false (Located.mk_elem TypedNull (Located.loc_of elem))","| TypedAttrWithValue(_, n, e, t) -> _add_attr_to_descriptor n false e","| TypedStaticAttr(_, n, t) -> _add_attr_to_descriptor n true (Located.mk_elem TypedNull (Located.loc_of elem))","| TypedStaticAttrWithValue(_, n, e, t) -> _add_attr_to_descriptor n true e",");","build_attrs_and_methods_descriptors class_descriptor methods_table q","(* Create new classes descriptors, but without methods and attributes for the moment. *)","let rec build_descriptors_1 classes_descriptors methods_table tree =","match tree with","| [] -> ()","| t::q -> (match Located.elem_of t with","| TypedClassdef (n, l) ->","let adv_class_descriptor = {","name=Located.elem_of n;","parent=\"Object\";","attributes=Hashtbl.create 10;","methods=Hashtbl.create 10;","}","in","Hashtbl.add classes_descriptors (Located.elem_of n) (ClassDescriptor(adv_class_descriptor));","build_attrs_and_methods_descriptors adv_class_descriptor methods_table l","| TypedClassdefWithParent (n, p, l) ->","let adv_class_descriptor = {","name=Located.elem_of n;","parent=string_of_classname (Located.elem_of p);","attributes=Hashtbl.create 10;","methods=Hashtbl.create 10;","}","in","Hashtbl.add classes_descriptors (Located.elem_of n) (ClassDescriptor(adv_class_descriptor));","build_attrs_and_methods_descriptors adv_class_descriptor methods_table l","| _ -> ()",");","build_descriptors_1 classes_descriptors methods_table q","let compile tree =","let classes_descriptors = Hashtbl.create 10","and methods_table = Hashtbl.create 30","in","build_basic_classes_descriptors classes_descriptors;","build_descriptors_1 classes_descriptors methods_table tree;","add_heritage_structures classes_descriptors methods_table;","classes_descriptors, methods_table"]},{"start":{"row":0,"column":0},"end":{"row":136,"column":35},"action":"insert","lines":["open Hashtbl","","open Structure","open TypedStructure","open CompileStructures","","(* Build the classes descriptors of the primitive classes. *)","let build_basic_classes_descriptors classes_descriptors =","\tHashtbl.add classes_descriptors \"Object\" ObjectClass;","\tHashtbl.add classes_descriptors \"Int\" IntClass;","\tHashtbl.add classes_descriptors \"Boolean\" BooleanClass;","\tHashtbl.add classes_descriptors \"String\" StringClass","","","let add_heritage_structures classes_descriptors methods_table =","\tlet (table_done: (string, bool) Hashtbl.t) = Hashtbl.create 10","","\tin let merge_attrs parent_desc class_desc =","\t\tmatch parent_desc with ","\t\t| ClassDescriptor cd ->","\t\t\tHashtbl.iter ","\t\t\t\t(fun k (v: attribute_descriptor) -> if v.static then () else Hashtbl.add class_desc.attributes k v) ","\t\t\t\tcd.attributes","\t\t| _ -> ()","","\tand merge_methods parent_desc class_desc =","\t\tlet add_method m_short_id m_id = ","\t\t\ttry","\t\t\t\tHashtbl.find class_desc.methods m_short_id;","\t\t\t\t()","\t\t\t\t(* Found, don't add the parent method definition *)","\t\t\twith Not_found ->","\t\t\t\t(* Not found, so the parent's definition must be added *)","\t\t\t\tHashtbl.add class_desc.methods m_short_id m_id","\t\tin match parent_desc with","\t\t| ClassDescriptor cd -> Hashtbl.iter add_method cd.methods","\t\t| _ -> ()","","\tin let add_heritage_structure class_name class_descriptor =","\t\tmatch class_descriptor with","\t\t| ClassDescriptor cd -> ","\t\t\tif Hashtbl.find table_done class_name <> true then begin","\t\t\t\tlet parent_descriptor = Hashtbl.find classes_descriptors cd.parent","\t\t\t\tin","\t\t\t\tHashtbl.replace table_done cd.name true;","\t\t\t\tmerge_attrs parent_descriptor cd;","\t\t\t\tmerge_methods parent_descriptor cd","\t\t\tend","\t\t\t(* The descriptor for that class has already been checked, return it as is. *)","\t\t| _ -> ()","\tin","\tHashtbl.iter (fun k _ -> Hashtbl.add table_done k false) classes_descriptors;","\tHashtbl.iter add_heritage_structure classes_descriptors","","","(* This function builds the methods and attributes descriptors of a class *)","(* class_descriptor is the class descriptor to which we add attributs and methods descriptors. *)","(* methods_table is the global methods' table. *)","(* l_methods_attrs is the list of typed methods and attributs defined in the class. *)","(* This function returns Unit, since it only modifies the two first parameters. *)","let rec build_attrs_and_methods_descriptors class_descriptor methods_table l_methods_attrs = ","","\tlet _add_method_to_descriptor m = ","\t\t(* Build a method descriptor and add it to the global methods table. Also, add a link to the method","\t\tin the list of methods of the current class descriptor. It returns Unit *)","\t\tlet build_method_descriptor m_name args m_expr m_static =","\t\t\tlet m_short_id = build_short_method_identifier m_name (params_types args)","\t\t\tin let m_id = class_descriptor.name ^ \"[\" ^ m_short_id ^ \"]\"","\t\t\tin ","\t\t\tHashtbl.add methods_table m_id ","\t\t\t\t{","\t\t\t\t\tstatic=m_static;","\t\t\t\t\tcore=m_expr;","\t\t\t\t\targs_names=params_names args;","\t\t\t\t};","\t\t\tHashtbl.add class_descriptor.methods m_short_id m_id","\t\tin match Located.elem_of m with ","\t\t\t| TypedMethod(r, n, args, e, t) -> build_method_descriptor (Located.elem_of n) args e false ","\t\t\t| TypedStaticMethod(r, n, args, e, t) -> build_method_descriptor (Located.elem_of n) args e true ","","\tand _add_attr_to_descriptor n static e =","\t\tHashtbl.add class_descriptor.attributes (Located.elem_of n) {default=e; static=static;}","","\tin match l_methods_attrs with","\t| [] -> ()","\t| elem::q -> (match (Located.elem_of elem) with ","\t\t\t| TypedMethod _ | TypedStaticMethod _ -> _add_method_to_descriptor elem;","\t\t\t| TypedAttr(_, n, t) -> _add_attr_to_descriptor n false (Located.mk_elem TypedNull (Located.loc_of elem))","\t\t\t| TypedAttrWithValue(_, n, e, t) -> _add_attr_to_descriptor n false e","\t\t\t| TypedStaticAttr(_, n, t) -> _add_attr_to_descriptor n true (Located.mk_elem TypedNull (Located.loc_of elem))","\t\t\t| TypedStaticAttrWithValue(_, n, e, t) -> _add_attr_to_descriptor n true e","\t\t);","\t\tbuild_attrs_and_methods_descriptors class_descriptor methods_table q","","","","(* Create new classes descriptors, but without methods and attributes for the moment. *)","let rec build_descriptors_1 classes_descriptors methods_table tree =","\tmatch tree with","\t| [] -> ()","\t| t::q -> (match Located.elem_of t with ","\t\t\t| TypedClassdef (n, l) ->","\t\t\t\tlet adv_class_descriptor = {","\t\t\t\t\tname=Located.elem_of n;","\t\t\t\t\tparent=\"Object\";","\t\t\t\t\tattributes=Hashtbl.create 10;","\t\t\t\t\tmethods=Hashtbl.create 10;","\t\t\t\t}","\t\t\t\tin ","\t\t\t\tHashtbl.add classes_descriptors (Located.elem_of n) (ClassDescriptor(adv_class_descriptor));","\t\t\t\tbuild_attrs_and_methods_descriptors adv_class_descriptor methods_table l","","\t\t\t| TypedClassdefWithParent (n, p, l) -> ","\t\t\t\tlet adv_class_descriptor = {","\t\t\t\t\tname=Located.elem_of n;","\t\t\t\t\tparent=string_of_classname (Located.elem_of p);","\t\t\t\t\tattributes=Hashtbl.create 10;","\t\t\t\t\tmethods=Hashtbl.create 10;","\t\t\t\t}","\t\t\t\tin ","\t\t\t\tHashtbl.add classes_descriptors (Located.elem_of n) (ClassDescriptor(adv_class_descriptor));","\t\t\t\tbuild_attrs_and_methods_descriptors adv_class_descriptor methods_table l","","\t\t\t| _ -> ()","\t\t);","\t\tbuild_descriptors_1 classes_descriptors methods_table q","","","let compile tree = ","\tlet classes_descriptors = Hashtbl.create 10","\tand methods_table = Hashtbl.create 30","\tin","\tbuild_basic_classes_descriptors classes_descriptors;","\tbuild_descriptors_1 classes_descriptors methods_table tree;","\tadd_heritage_structures classes_descriptors methods_table;","","\tclasses_descriptors, methods_table"]}]}],[{"group":"doc","deltas":[{"start":{"row":0,"column":0},"end":{"row":136,"column":35},"action":"remove","lines":["open Hashtbl","","open Structure","open TypedStructure","open CompileStructures","","(* Build the classes descriptors of the primitive classes. *)","let build_basic_classes_descriptors classes_descriptors =","\tHashtbl.add classes_descriptors \"Object\" ObjectClass;","\tHashtbl.add classes_descriptors \"Int\" IntClass;","\tHashtbl.add classes_descriptors \"Boolean\" BooleanClass;","\tHashtbl.add classes_descriptors \"String\" StringClass","","","let add_heritage_structures classes_descriptors methods_table =","\tlet (table_done: (string, bool) Hashtbl.t) = Hashtbl.create 10","","\tin let merge_attrs parent_desc class_desc =","\t\tmatch parent_desc with ","\t\t| ClassDescriptor cd ->","\t\t\tHashtbl.iter ","\t\t\t\t(fun k (v: attribute_descriptor) -> if v.static then () else Hashtbl.add class_desc.attributes k v) ","\t\t\t\tcd.attributes","\t\t| _ -> ()","","\tand merge_methods parent_desc class_desc =","\t\tlet add_method m_short_id m_id = ","\t\t\ttry","\t\t\t\tHashtbl.find class_desc.methods m_short_id;","\t\t\t\t()","\t\t\t\t(* Found, don't add the parent method definition *)","\t\t\twith Not_found ->","\t\t\t\t(* Not found, so the parent's definition must be added *)","\t\t\t\tHashtbl.add class_desc.methods m_short_id m_id","\t\tin match parent_desc with","\t\t| ClassDescriptor cd -> Hashtbl.iter add_method cd.methods","\t\t| _ -> ()","","\tin let add_heritage_structure class_name class_descriptor =","\t\tmatch class_descriptor with","\t\t| ClassDescriptor cd -> ","\t\t\tif Hashtbl.find table_done class_name <> true then begin","\t\t\t\tlet parent_descriptor = Hashtbl.find classes_descriptors cd.parent","\t\t\t\tin","\t\t\t\tHashtbl.replace table_done cd.name true;","\t\t\t\tmerge_attrs parent_descriptor cd;","\t\t\t\tmerge_methods parent_descriptor cd","\t\t\tend","\t\t\t(* The descriptor for that class has already been checked, return it as is. *)","\t\t| _ -> ()","\tin","\tHashtbl.iter (fun k _ -> Hashtbl.add table_done k false) classes_descriptors;","\tHashtbl.iter add_heritage_structure classes_descriptors","","","(* This function builds the methods and attributes descriptors of a class *)","(* class_descriptor is the class descriptor to which we add attributs and methods descriptors. *)","(* methods_table is the global methods' table. *)","(* l_methods_attrs is the list of typed methods and attributs defined in the class. *)","(* This function returns Unit, since it only modifies the two first parameters. *)","let rec build_attrs_and_methods_descriptors class_descriptor methods_table l_methods_attrs = ","","\tlet _add_method_to_descriptor m = ","\t\t(* Build a method descriptor and add it to the global methods table. Also, add a link to the method","\t\tin the list of methods of the current class descriptor. It returns Unit *)","\t\tlet build_method_descriptor m_name args m_expr m_static =","\t\t\tlet m_short_id = build_short_method_identifier m_name (params_types args)","\t\t\tin let m_id = class_descriptor.name ^ \"[\" ^ m_short_id ^ \"]\"","\t\t\tin ","\t\t\tHashtbl.add methods_table m_id ","\t\t\t\t{","\t\t\t\t\tstatic=m_static;","\t\t\t\t\tcore=m_expr;","\t\t\t\t\targs_names=params_names args;","\t\t\t\t};","\t\t\tHashtbl.add class_descriptor.methods m_short_id m_id","\t\tin match Located.elem_of m with ","\t\t\t| TypedMethod(r, n, args, e, t) -> build_method_descriptor (Located.elem_of n) args e false ","\t\t\t| TypedStaticMethod(r, n, args, e, t) -> build_method_descriptor (Located.elem_of n) args e true ","","\tand _add_attr_to_descriptor n static e =","\t\tHashtbl.add class_descriptor.attributes (Located.elem_of n) {default=e; static=static;}","","\tin match l_methods_attrs with","\t| [] -> ()","\t| elem::q -> (match (Located.elem_of elem) with ","\t\t\t| TypedMethod _ | TypedStaticMethod _ -> _add_method_to_descriptor elem;","\t\t\t| TypedAttr(_, n, t) -> _add_attr_to_descriptor n false (Located.mk_elem TypedNull (Located.loc_of elem))","\t\t\t| TypedAttrWithValue(_, n, e, t) -> _add_attr_to_descriptor n false e","\t\t\t| TypedStaticAttr(_, n, t) -> _add_attr_to_descriptor n true (Located.mk_elem TypedNull (Located.loc_of elem))","\t\t\t| TypedStaticAttrWithValue(_, n, e, t) -> _add_attr_to_descriptor n true e","\t\t);","\t\tbuild_attrs_and_methods_descriptors class_descriptor methods_table q","","","","(* Create new classes descriptors, but without methods and attributes for the moment. *)","let rec build_descriptors_1 classes_descriptors methods_table tree =","\tmatch tree with","\t| [] -> ()","\t| t::q -> (match Located.elem_of t with ","\t\t\t| TypedClassdef (n, l) ->","\t\t\t\tlet adv_class_descriptor = {","\t\t\t\t\tname=Located.elem_of n;","\t\t\t\t\tparent=\"Object\";","\t\t\t\t\tattributes=Hashtbl.create 10;","\t\t\t\t\tmethods=Hashtbl.create 10;","\t\t\t\t}","\t\t\t\tin ","\t\t\t\tHashtbl.add classes_descriptors (Located.elem_of n) (ClassDescriptor(adv_class_descriptor));","\t\t\t\tbuild_attrs_and_methods_descriptors adv_class_descriptor methods_table l","","\t\t\t| TypedClassdefWithParent (n, p, l) -> ","\t\t\t\tlet adv_class_descriptor = {","\t\t\t\t\tname=Located.elem_of n;","\t\t\t\t\tparent=string_of_classname (Located.elem_of p);","\t\t\t\t\tattributes=Hashtbl.create 10;","\t\t\t\t\tmethods=Hashtbl.create 10;","\t\t\t\t}","\t\t\t\tin ","\t\t\t\tHashtbl.add classes_descriptors (Located.elem_of n) (ClassDescriptor(adv_class_descriptor));","\t\t\t\tbuild_attrs_and_methods_descriptors adv_class_descriptor methods_table l","","\t\t\t| _ -> ()","\t\t);","\t\tbuild_descriptors_1 classes_descriptors methods_table q","","","let compile tree = ","\tlet classes_descriptors = Hashtbl.create 10","\tand methods_table = Hashtbl.create 30","\tin","\tbuild_basic_classes_descriptors classes_descriptors;","\tbuild_descriptors_1 classes_descriptors methods_table tree;","\tadd_heritage_structures classes_descriptors methods_table;","","\tclasses_descriptors, methods_table"]}]}]]},"ace":{"folds":[],"scrolltop":1694.5,"scrollleft":0,"selection":{"start":{"row":127,"column":0},"end":{"row":127,"column":0},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":0},"timestamp":1425504625000,"hash":"4e5c7022b443565930f395198212a5c85915a8c9"}