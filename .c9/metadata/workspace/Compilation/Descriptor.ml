{"filter":false,"title":"Descriptor.ml","tooltip":"/Compilation/Descriptor.ml","undoManager":{"mark":22,"position":22,"stack":[[{"group":"doc","deltas":[{"start":{"row":0,"column":0},"end":{"row":36,"column":41},"action":"insert","lines":["open Hashtbl","open TypedStructure","type attribute_descriptor = {","static: bool;","default: typed_expr Located.t;","}","type method_descriptor = {","static: bool;","args_names: string list;","core: typed_expr Located.t;","}","(*","Class descriptor, with:","name: name of the class","attributes: hash table with keys: name of an attribute, values: typed expression of the default values","methods: Hash table with keys: id of a method without the class, values: keys from the global methods table","*)","type advanced_class_descriptor = {","name: string;\t(* Name is redundant since a class descriptor is the value of a hash table,","which keys are the names of the classes *)","parent: string;\t(* We keep this information for casting, at least. *)","attributes: (string, attribute_descriptor) Hashtbl.t;","methods: (string, string) Hashtbl.t;","}","type class_descriptor =","| ClassDescriptor of advanced_class_descriptor","| ObjectClass","| IntClass","| BooleanClass","| StringClass","let build_short_method_identifier (m_name: string) (args: string list) =","let rec args_str = function","| [] -> \"\"","| [t] -> t","| t::q -> t ^ \",\" ^ (args_str q)","(* Short Identifier looks like: m(Int,Boolean) *)","in (m_name ^ \"(\" ^ (args_str args) ^ \")\")"]}]}],[{"group":"doc","deltas":[{"start":{"row":0,"column":12},"end":{"row":1,"column":0},"action":"insert","lines":["",""]}]}],[{"group":"doc","deltas":[{"start":{"row":0,"column":12},"end":{"row":1,"column":0},"action":"remove","lines":["",""]}]}],[{"group":"doc","deltas":[{"start":{"row":1,"column":19},"end":{"row":2,"column":0},"action":"insert","lines":["",""]}]}],[{"group":"doc","deltas":[{"start":{"row":0,"column":0},"end":{"row":37,"column":41},"action":"remove","lines":["open Hashtbl","open TypedStructure","","type attribute_descriptor = {","static: bool;","default: typed_expr Located.t;","}","type method_descriptor = {","static: bool;","args_names: string list;","core: typed_expr Located.t;","}","(*","Class descriptor, with:","name: name of the class","attributes: hash table with keys: name of an attribute, values: typed expression of the default values","methods: Hash table with keys: id of a method without the class, values: keys from the global methods table","*)","type advanced_class_descriptor = {","name: string;\t(* Name is redundant since a class descriptor is the value of a hash table,","which keys are the names of the classes *)","parent: string;\t(* We keep this information for casting, at least. *)","attributes: (string, attribute_descriptor) Hashtbl.t;","methods: (string, string) Hashtbl.t;","}","type class_descriptor =","| ClassDescriptor of advanced_class_descriptor","| ObjectClass","| IntClass","| BooleanClass","| StringClass","let build_short_method_identifier (m_name: string) (args: string list) =","let rec args_str = function","| [] -> \"\"","| [t] -> t","| t::q -> t ^ \",\" ^ (args_str q)","(* Short Identifier looks like: m(Int,Boolean) *)","in (m_name ^ \"(\" ^ (args_str args) ^ \")\")"]},{"start":{"row":0,"column":0},"end":{"row":116,"column":34},"action":"insert","lines":["open Hashtbl","open Structure","open TypedStructure","open CompileStructures","(* Build the classes descriptors of the primitive classes. *)","let build_basic_classes_descriptors classes_descriptors =","Hashtbl.add classes_descriptors \"Object\" ObjectClass;","Hashtbl.add classes_descriptors \"Int\" IntClass;","Hashtbl.add classes_descriptors \"Boolean\" BooleanClass;","Hashtbl.add classes_descriptors \"String\" StringClass","let add_heritage_structures classes_descriptors methods_table =","let (table_done: (string, bool) Hashtbl.t) = Hashtbl.create 10","in let merge_attrs parent_desc class_desc =","match parent_desc with","| ClassDescriptor cd ->","Hashtbl.iter","(fun k (v: attribute_descriptor) -> if v.static then () else Hashtbl.add class_desc.attributes k v)","cd.attributes","| _ -> ()","and merge_methods parent_desc class_desc =","let add_method m_short_id m_id =","try","Hashtbl.find class_desc.methods m_short_id;","()","(* Found, don't add the parent method definition *)","with Not_found ->","(* Not found, so the parent's definition must be added *)","Hashtbl.add class_desc.methods m_short_id m_id","in match parent_desc with","| ClassDescriptor cd -> Hashtbl.iter add_method cd.methods","| _ -> ()","in let add_heritage_structure class_name class_descriptor =","match class_descriptor with","| ClassDescriptor cd ->","if Hashtbl.find table_done class_name <> true then begin","let parent_descriptor = Hashtbl.find classes_descriptors cd.parent","in","Hashtbl.replace table_done cd.name true;","merge_attrs parent_descriptor cd;","merge_methods parent_descriptor cd","end","(* The descriptor for that class has already been checked, return it as is. *)","| _ -> ()","in","Hashtbl.iter (fun k _ -> Hashtbl.add table_done k false) classes_descriptors;","Hashtbl.iter add_heritage_structure classes_descriptors","(* This function builds the methods and attributes descriptors of a class *)","(* class_descriptor is the class descriptor to which we add attributs and methods descriptors. *)","(* methods_table is the global methods' table. *)","(* l_methods_attrs is the list of typed methods and attributs defined in the class. *)","(* This function returns Unit, since it only modifies the two first parameters. *)","let rec build_attrs_and_methods_descriptors class_descriptor methods_table l_methods_attrs =","let _add_method_to_descriptor m =","(* Build a method descriptor and add it to the global methods table. Also, add a link to the method","in the list of methods of the current class descriptor. It returns Unit *)","let build_method_descriptor m_name args m_expr m_static =","let m_short_id = build_short_method_identifier m_name (params_types args)","in let m_id = class_descriptor.name ^ \"[\" ^ m_short_id ^ \"]\"","in","Hashtbl.add methods_table m_id","{","static=m_static;","core=m_expr;","args_names=params_names args;","};","Hashtbl.add class_descriptor.methods m_short_id m_id","in match Located.elem_of m with","| TypedMethod(r, n, args, e, t) -> build_method_descriptor (Located.elem_of n) args e false","| TypedStaticMethod(r, n, args, e, t) -> build_method_descriptor (Located.elem_of n) args e true","and _add_attr_to_descriptor n static e =","Hashtbl.add class_descriptor.attributes (Located.elem_of n) {default=e; static=static;}","in match l_methods_attrs with","| [] -> ()","| elem::q -> (match (Located.elem_of elem) with","| TypedMethod _ | TypedStaticMethod _ -> _add_method_to_descriptor elem;","| TypedAttr(_, n, t) -> _add_attr_to_descriptor n false (Located.mk_elem TypedNull (Located.loc_of elem))","| TypedAttrWithValue(_, n, e, t) -> _add_attr_to_descriptor n false e","| TypedStaticAttr(_, n, t) -> _add_attr_to_descriptor n true (Located.mk_elem TypedNull (Located.loc_of elem))","| TypedStaticAttrWithValue(_, n, e, t) -> _add_attr_to_descriptor n true e",");","build_attrs_and_methods_descriptors class_descriptor methods_table q","(* Create new classes descriptors, but without methods and attributes for the moment. *)","let rec build_descriptors_1 classes_descriptors methods_table tree =","match tree with","| [] -> ()","| t::q -> (match Located.elem_of t with","| TypedClassdef (n, l) ->","let adv_class_descriptor = {","name=Located.elem_of n;","parent=\"Object\";","attributes=Hashtbl.create 10;","methods=Hashtbl.create 10;","}","in","Hashtbl.add classes_descriptors (Located.elem_of n) (ClassDescriptor(adv_class_descriptor));","build_attrs_and_methods_descriptors adv_class_descriptor methods_table l","| TypedClassdefWithParent (n, p, l) ->","let adv_class_descriptor = {","name=Located.elem_of n;","parent=string_of_classname (Located.elem_of p);","attributes=Hashtbl.create 10;","methods=Hashtbl.create 10;","}","in","Hashtbl.add classes_descriptors (Located.elem_of n) (ClassDescriptor(adv_class_descriptor));","build_attrs_and_methods_descriptors adv_class_descriptor methods_table l","| _ -> ()",");","build_descriptors_1 classes_descriptors methods_table q","let compile tree =","let classes_descriptors = Hashtbl.create 10","and methods_table = Hashtbl.create 30","in","build_basic_classes_descriptors classes_descriptors;","build_descriptors_1 classes_descriptors methods_table tree;","add_heritage_structures classes_descriptors methods_table;","classes_descriptors, methods_table"]}]}],[{"group":"doc","deltas":[{"start":{"row":6,"column":0},"end":{"row":6,"column":4},"action":"insert","lines":["    "]},{"start":{"row":7,"column":0},"end":{"row":7,"column":4},"action":"insert","lines":["    "]},{"start":{"row":8,"column":0},"end":{"row":8,"column":4},"action":"insert","lines":["    "]},{"start":{"row":9,"column":0},"end":{"row":9,"column":4},"action":"insert","lines":["    "]}]}],[{"group":"doc","deltas":[{"start":{"row":4,"column":1},"end":{"row":5,"column":0},"action":"insert","lines":["",""]},{"start":{"row":5,"column":0},"end":{"row":5,"column":4},"action":"insert","lines":["    "]}]}],[{"group":"doc","deltas":[{"start":{"row":5,"column":0},"end":{"row":5,"column":4},"action":"remove","lines":["    "]}]}],[{"group":"doc","deltas":[{"start":{"row":4,"column":1},"end":{"row":5,"column":0},"action":"remove","lines":["",""]}]}],[{"group":"doc","deltas":[{"start":{"row":4,"column":0},"end":{"row":5,"column":0},"action":"insert","lines":["",""]}]}],[{"group":"doc","deltas":[{"start":{"row":12,"column":0},"end":{"row":12,"column":4},"action":"insert","lines":["    "]}]}],[{"group":"doc","deltas":[{"start":{"row":0,"column":0},"end":{"row":117,"column":34},"action":"remove","lines":["open Hashtbl","open Structure","open TypedStructure","open CompileStructures","","(* Build the classes descriptors of the primitive classes. *)","let build_basic_classes_descriptors classes_descriptors =","    Hashtbl.add classes_descriptors \"Object\" ObjectClass;","    Hashtbl.add classes_descriptors \"Int\" IntClass;","    Hashtbl.add classes_descriptors \"Boolean\" BooleanClass;","    Hashtbl.add classes_descriptors \"String\" StringClass","let add_heritage_structures classes_descriptors methods_table =","    let (table_done: (string, bool) Hashtbl.t) = Hashtbl.create 10","in let merge_attrs parent_desc class_desc =","match parent_desc with","| ClassDescriptor cd ->","Hashtbl.iter","(fun k (v: attribute_descriptor) -> if v.static then () else Hashtbl.add class_desc.attributes k v)","cd.attributes","| _ -> ()","and merge_methods parent_desc class_desc =","let add_method m_short_id m_id =","try","Hashtbl.find class_desc.methods m_short_id;","()","(* Found, don't add the parent method definition *)","with Not_found ->","(* Not found, so the parent's definition must be added *)","Hashtbl.add class_desc.methods m_short_id m_id","in match parent_desc with","| ClassDescriptor cd -> Hashtbl.iter add_method cd.methods","| _ -> ()","in let add_heritage_structure class_name class_descriptor =","match class_descriptor with","| ClassDescriptor cd ->","if Hashtbl.find table_done class_name <> true then begin","let parent_descriptor = Hashtbl.find classes_descriptors cd.parent","in","Hashtbl.replace table_done cd.name true;","merge_attrs parent_descriptor cd;","merge_methods parent_descriptor cd","end","(* The descriptor for that class has already been checked, return it as is. *)","| _ -> ()","in","Hashtbl.iter (fun k _ -> Hashtbl.add table_done k false) classes_descriptors;","Hashtbl.iter add_heritage_structure classes_descriptors","(* This function builds the methods and attributes descriptors of a class *)","(* class_descriptor is the class descriptor to which we add attributs and methods descriptors. *)","(* methods_table is the global methods' table. *)","(* l_methods_attrs is the list of typed methods and attributs defined in the class. *)","(* This function returns Unit, since it only modifies the two first parameters. *)","let rec build_attrs_and_methods_descriptors class_descriptor methods_table l_methods_attrs =","let _add_method_to_descriptor m =","(* Build a method descriptor and add it to the global methods table. Also, add a link to the method","in the list of methods of the current class descriptor. It returns Unit *)","let build_method_descriptor m_name args m_expr m_static =","let m_short_id = build_short_method_identifier m_name (params_types args)","in let m_id = class_descriptor.name ^ \"[\" ^ m_short_id ^ \"]\"","in","Hashtbl.add methods_table m_id","{","static=m_static;","core=m_expr;","args_names=params_names args;","};","Hashtbl.add class_descriptor.methods m_short_id m_id","in match Located.elem_of m with","| TypedMethod(r, n, args, e, t) -> build_method_descriptor (Located.elem_of n) args e false","| TypedStaticMethod(r, n, args, e, t) -> build_method_descriptor (Located.elem_of n) args e true","and _add_attr_to_descriptor n static e =","Hashtbl.add class_descriptor.attributes (Located.elem_of n) {default=e; static=static;}","in match l_methods_attrs with","| [] -> ()","| elem::q -> (match (Located.elem_of elem) with","| TypedMethod _ | TypedStaticMethod _ -> _add_method_to_descriptor elem;","| TypedAttr(_, n, t) -> _add_attr_to_descriptor n false (Located.mk_elem TypedNull (Located.loc_of elem))","| TypedAttrWithValue(_, n, e, t) -> _add_attr_to_descriptor n false e","| TypedStaticAttr(_, n, t) -> _add_attr_to_descriptor n true (Located.mk_elem TypedNull (Located.loc_of elem))","| TypedStaticAttrWithValue(_, n, e, t) -> _add_attr_to_descriptor n true e",");","build_attrs_and_methods_descriptors class_descriptor methods_table q","(* Create new classes descriptors, but without methods and attributes for the moment. *)","let rec build_descriptors_1 classes_descriptors methods_table tree =","match tree with","| [] -> ()","| t::q -> (match Located.elem_of t with","| TypedClassdef (n, l) ->","let adv_class_descriptor = {","name=Located.elem_of n;","parent=\"Object\";","attributes=Hashtbl.create 10;","methods=Hashtbl.create 10;","}","in","Hashtbl.add classes_descriptors (Located.elem_of n) (ClassDescriptor(adv_class_descriptor));","build_attrs_and_methods_descriptors adv_class_descriptor methods_table l","| TypedClassdefWithParent (n, p, l) ->","let adv_class_descriptor = {","name=Located.elem_of n;","parent=string_of_classname (Located.elem_of p);","attributes=Hashtbl.create 10;","methods=Hashtbl.create 10;","}","in","Hashtbl.add classes_descriptors (Located.elem_of n) (ClassDescriptor(adv_class_descriptor));","build_attrs_and_methods_descriptors adv_class_descriptor methods_table l","| _ -> ()",");","build_descriptors_1 classes_descriptors methods_table q","let compile tree =","let classes_descriptors = Hashtbl.create 10","and methods_table = Hashtbl.create 30","in","build_basic_classes_descriptors classes_descriptors;","build_descriptors_1 classes_descriptors methods_table tree;","add_heritage_structures classes_descriptors methods_table;","classes_descriptors, methods_table"]},{"start":{"row":0,"column":0},"end":{"row":66,"column":0},"action":"insert","lines":["(* Realise la phase de compilation *)","open TypeEnv","open AST","open Location","","(* Definit les attributs des objects d'une classe *)","let rec makeAttrs env attrlist =","  match attrlist with ","    | [] -> []","    | a::others ->","      match a.adefault with","        | Some e -> (a.aname, e)::(makeAttrs env others)","        | None -> match a.atype with","            | \"Int\" -> ","              let e = { edesc = Val(Int(0)); eloc = Location.none; etype = None} in","              (a.aname,e)::(makeAttrs env others)","            | \"String\" -> ","              let e = { edesc = Val(String(\"\")); eloc = Location.none; etype = None} in","              (a.aname,e)::(makeAttrs env others)","            | \"Boolean\" -> ","              let e = { edesc = Val(Boolean(false)); eloc = Location.none; etype = None} in","              (a.aname,e)::(makeAttrs env others)","            | \"Null\" -> ","              let e = { edesc = Val(Null); eloc = Location.none; etype = None} in","              (a.aname,e)::(makeAttrs env others)","            | _ -> ","              let e = { edesc = Val(Reference(-1)); eloc = Location.none; etype = None} in","              (a.aname,e)::(makeAttrs env others)","","let rec getArgsName args =","  match args with ","    | [] -> []","    | (aname, _)::others -> aname::(getArgsName others)","","let addFun cname fname fbody args env = ","  let fargs = getArgsName args in","  let fid = TypeEnv.getFunID cname fname in","  let f = TypeEnv.makeFun fargs fbody in","  TypeEnv.addFun env fid f","","(* Compile les fonctions d'une classe *)","let rec makeFuns cname funs env =","  match funs with","    | [] -> env","    | f::others ->","      TypeEnv.addFunToClass cname f.mname env;","      let newEnv = addFun cname f.mname f.mbody f.margstype env in","      makeFuns cname others newEnv","        ","let rec makeClassEnv typesAST env = ","  match typesAST with","    | [] -> env","    | c::others ->","      let newClass = (TypeEnv.makeClass c.cname c.cparent) in","      (* On ajoute la classes à l'environnement *)","      let envWithClasses = TypeEnv.addClass env c.cname newClass in","      let cattrs = makeAttrs envWithClasses c.cattributes in","      TypeEnv.addAttrsToClass c.cname cattrs envWithClasses ;","      (* On compile les méthodes définies dans la classe *)","      let envWithFuns = makeFuns c.cname c.cmethods envWithClasses in","      (* On effectue le même travail pour les autres classes *)","      makeClassEnv others envWithFuns","","let compile typesAST =","  makeClassEnv typesAST (TypeEnv.initialEnv())","    ",""]}]}],[{"group":"doc","deltas":[{"start":{"row":8,"column":4},"end":{"row":8,"column":8},"action":"insert","lines":["    "]}]}],[{"group":"doc","deltas":[{"start":{"row":8,"column":0},"end":{"row":8,"column":4},"action":"remove","lines":["    "]}]}],[{"group":"doc","deltas":[{"start":{"row":8,"column":4},"end":{"row":8,"column":5},"action":"insert","lines":[" "]}]}],[{"group":"doc","deltas":[{"start":{"row":8,"column":4},"end":{"row":8,"column":5},"action":"remove","lines":[" "]}]}],[{"group":"doc","deltas":[{"start":{"row":0,"column":0},"end":{"row":66,"column":0},"action":"remove","lines":["(* Realise la phase de compilation *)","open TypeEnv","open AST","open Location","","(* Definit les attributs des objects d'une classe *)","let rec makeAttrs env attrlist =","  match attrlist with ","    | [] -> []","    | a::others ->","      match a.adefault with","        | Some e -> (a.aname, e)::(makeAttrs env others)","        | None -> match a.atype with","            | \"Int\" -> ","              let e = { edesc = Val(Int(0)); eloc = Location.none; etype = None} in","              (a.aname,e)::(makeAttrs env others)","            | \"String\" -> ","              let e = { edesc = Val(String(\"\")); eloc = Location.none; etype = None} in","              (a.aname,e)::(makeAttrs env others)","            | \"Boolean\" -> ","              let e = { edesc = Val(Boolean(false)); eloc = Location.none; etype = None} in","              (a.aname,e)::(makeAttrs env others)","            | \"Null\" -> ","              let e = { edesc = Val(Null); eloc = Location.none; etype = None} in","              (a.aname,e)::(makeAttrs env others)","            | _ -> ","              let e = { edesc = Val(Reference(-1)); eloc = Location.none; etype = None} in","              (a.aname,e)::(makeAttrs env others)","","let rec getArgsName args =","  match args with ","    | [] -> []","    | (aname, _)::others -> aname::(getArgsName others)","","let addFun cname fname fbody args env = ","  let fargs = getArgsName args in","  let fid = TypeEnv.getFunID cname fname in","  let f = TypeEnv.makeFun fargs fbody in","  TypeEnv.addFun env fid f","","(* Compile les fonctions d'une classe *)","let rec makeFuns cname funs env =","  match funs with","    | [] -> env","    | f::others ->","      TypeEnv.addFunToClass cname f.mname env;","      let newEnv = addFun cname f.mname f.mbody f.margstype env in","      makeFuns cname others newEnv","        ","let rec makeClassEnv typesAST env = ","  match typesAST with","    | [] -> env","    | c::others ->","      let newClass = (TypeEnv.makeClass c.cname c.cparent) in","      (* On ajoute la classes à l'environnement *)","      let envWithClasses = TypeEnv.addClass env c.cname newClass in","      let cattrs = makeAttrs envWithClasses c.cattributes in","      TypeEnv.addAttrsToClass c.cname cattrs envWithClasses ;","      (* On compile les méthodes définies dans la classe *)","      let envWithFuns = makeFuns c.cname c.cmethods envWithClasses in","      (* On effectue le même travail pour les autres classes *)","      makeClassEnv others envWithFuns","","let compile typesAST =","  makeClassEnv typesAST (TypeEnv.initialEnv())","    ",""]},{"start":{"row":0,"column":0},"end":{"row":136,"column":35},"action":"insert","lines":["open Hashtbl","","open Structure","open TypedStructure","open CompileStructures","","(* Build the classes descriptors of the primitive classes. *)","let build_basic_classes_descriptors classes_descriptors =","\tHashtbl.add classes_descriptors \"Object\" ObjectClass;","\tHashtbl.add classes_descriptors \"Int\" IntClass;","\tHashtbl.add classes_descriptors \"Boolean\" BooleanClass;","\tHashtbl.add classes_descriptors \"String\" StringClass","","","let add_heritage_structures classes_descriptors methods_table =","\tlet (table_done: (string, bool) Hashtbl.t) = Hashtbl.create 10","","\tin let merge_attrs parent_desc class_desc =","\t\tmatch parent_desc with ","\t\t| ClassDescriptor cd ->","\t\t\tHashtbl.iter ","\t\t\t\t(fun k (v: attribute_descriptor) -> if v.static then () else Hashtbl.add class_desc.attributes k v) ","\t\t\t\tcd.attributes","\t\t| _ -> ()","","\tand merge_methods parent_desc class_desc =","\t\tlet add_method m_short_id m_id = ","\t\t\ttry","\t\t\t\tHashtbl.find class_desc.methods m_short_id;","\t\t\t\t()","\t\t\t\t(* Found, don't add the parent method definition *)","\t\t\twith Not_found ->","\t\t\t\t(* Not found, so the parent's definition must be added *)","\t\t\t\tHashtbl.add class_desc.methods m_short_id m_id","\t\tin match parent_desc with","\t\t| ClassDescriptor cd -> Hashtbl.iter add_method cd.methods","\t\t| _ -> ()","","\tin let add_heritage_structure class_name class_descriptor =","\t\tmatch class_descriptor with","\t\t| ClassDescriptor cd -> ","\t\t\tif Hashtbl.find table_done class_name <> true then begin","\t\t\t\tlet parent_descriptor = Hashtbl.find classes_descriptors cd.parent","\t\t\t\tin","\t\t\t\tHashtbl.replace table_done cd.name true;","\t\t\t\tmerge_attrs parent_descriptor cd;","\t\t\t\tmerge_methods parent_descriptor cd","\t\t\tend","\t\t\t(* The descriptor for that class has already been checked, return it as is. *)","\t\t| _ -> ()","\tin","\tHashtbl.iter (fun k _ -> Hashtbl.add table_done k false) classes_descriptors;","\tHashtbl.iter add_heritage_structure classes_descriptors","","","(* This function builds the methods and attributes descriptors of a class *)","(* class_descriptor is the class descriptor to which we add attributs and methods descriptors. *)","(* methods_table is the global methods' table. *)","(* l_methods_attrs is the list of typed methods and attributs defined in the class. *)","(* This function returns Unit, since it only modifies the two first parameters. *)","let rec build_attrs_and_methods_descriptors class_descriptor methods_table l_methods_attrs = ","","\tlet _add_method_to_descriptor m = ","\t\t(* Build a method descriptor and add it to the global methods table. Also, add a link to the method","\t\tin the list of methods of the current class descriptor. It returns Unit *)","\t\tlet build_method_descriptor m_name args m_expr m_static =","\t\t\tlet m_short_id = build_short_method_identifier m_name (params_types args)","\t\t\tin let m_id = class_descriptor.name ^ \"[\" ^ m_short_id ^ \"]\"","\t\t\tin ","\t\t\tHashtbl.add methods_table m_id ","\t\t\t\t{","\t\t\t\t\tstatic=m_static;","\t\t\t\t\tcore=m_expr;","\t\t\t\t\targs_names=params_names args;","\t\t\t\t};","\t\t\tHashtbl.add class_descriptor.methods m_short_id m_id","\t\tin match Located.elem_of m with ","\t\t\t| TypedMethod(r, n, args, e, t) -> build_method_descriptor (Located.elem_of n) args e false ","\t\t\t| TypedStaticMethod(r, n, args, e, t) -> build_method_descriptor (Located.elem_of n) args e true ","","\tand _add_attr_to_descriptor n static e =","\t\tHashtbl.add class_descriptor.attributes (Located.elem_of n) {default=e; static=static;}","","\tin match l_methods_attrs with","\t| [] -> ()","\t| elem::q -> (match (Located.elem_of elem) with ","\t\t\t| TypedMethod _ | TypedStaticMethod _ -> _add_method_to_descriptor elem;","\t\t\t| TypedAttr(_, n, t) -> _add_attr_to_descriptor n false (Located.mk_elem TypedNull (Located.loc_of elem))","\t\t\t| TypedAttrWithValue(_, n, e, t) -> _add_attr_to_descriptor n false e","\t\t\t| TypedStaticAttr(_, n, t) -> _add_attr_to_descriptor n true (Located.mk_elem TypedNull (Located.loc_of elem))","\t\t\t| TypedStaticAttrWithValue(_, n, e, t) -> _add_attr_to_descriptor n true e","\t\t);","\t\tbuild_attrs_and_methods_descriptors class_descriptor methods_table q","","","","(* Create new classes descriptors, but without methods and attributes for the moment. *)","let rec build_descriptors_1 classes_descriptors methods_table tree =","\tmatch tree with","\t| [] -> ()","\t| t::q -> (match Located.elem_of t with ","\t\t\t| TypedClassdef (n, l) ->","\t\t\t\tlet adv_class_descriptor = {","\t\t\t\t\tname=Located.elem_of n;","\t\t\t\t\tparent=\"Object\";","\t\t\t\t\tattributes=Hashtbl.create 10;","\t\t\t\t\tmethods=Hashtbl.create 10;","\t\t\t\t}","\t\t\t\tin ","\t\t\t\tHashtbl.add classes_descriptors (Located.elem_of n) (ClassDescriptor(adv_class_descriptor));","\t\t\t\tbuild_attrs_and_methods_descriptors adv_class_descriptor methods_table l","","\t\t\t| TypedClassdefWithParent (n, p, l) -> ","\t\t\t\tlet adv_class_descriptor = {","\t\t\t\t\tname=Located.elem_of n;","\t\t\t\t\tparent=string_of_classname (Located.elem_of p);","\t\t\t\t\tattributes=Hashtbl.create 10;","\t\t\t\t\tmethods=Hashtbl.create 10;","\t\t\t\t}","\t\t\t\tin ","\t\t\t\tHashtbl.add classes_descriptors (Located.elem_of n) (ClassDescriptor(adv_class_descriptor));","\t\t\t\tbuild_attrs_and_methods_descriptors adv_class_descriptor methods_table l","","\t\t\t| _ -> ()","\t\t);","\t\tbuild_descriptors_1 classes_descriptors methods_table q","","","let compile tree = ","\tlet classes_descriptors = Hashtbl.create 10","\tand methods_table = Hashtbl.create 30","\tin","\tbuild_basic_classes_descriptors classes_descriptors;","\tbuild_descriptors_1 classes_descriptors methods_table tree;","\tadd_heritage_structures classes_descriptors methods_table;","","\tclasses_descriptors, methods_table"]}]}],[{"group":"doc","deltas":[{"start":{"row":0,"column":0},"end":{"row":136,"column":35},"action":"remove","lines":["open Hashtbl","","open Structure","open TypedStructure","open CompileStructures","","(* Build the classes descriptors of the primitive classes. *)","let build_basic_classes_descriptors classes_descriptors =","\tHashtbl.add classes_descriptors \"Object\" ObjectClass;","\tHashtbl.add classes_descriptors \"Int\" IntClass;","\tHashtbl.add classes_descriptors \"Boolean\" BooleanClass;","\tHashtbl.add classes_descriptors \"String\" StringClass","","","let add_heritage_structures classes_descriptors methods_table =","\tlet (table_done: (string, bool) Hashtbl.t) = Hashtbl.create 10","","\tin let merge_attrs parent_desc class_desc =","\t\tmatch parent_desc with ","\t\t| ClassDescriptor cd ->","\t\t\tHashtbl.iter ","\t\t\t\t(fun k (v: attribute_descriptor) -> if v.static then () else Hashtbl.add class_desc.attributes k v) ","\t\t\t\tcd.attributes","\t\t| _ -> ()","","\tand merge_methods parent_desc class_desc =","\t\tlet add_method m_short_id m_id = ","\t\t\ttry","\t\t\t\tHashtbl.find class_desc.methods m_short_id;","\t\t\t\t()","\t\t\t\t(* Found, don't add the parent method definition *)","\t\t\twith Not_found ->","\t\t\t\t(* Not found, so the parent's definition must be added *)","\t\t\t\tHashtbl.add class_desc.methods m_short_id m_id","\t\tin match parent_desc with","\t\t| ClassDescriptor cd -> Hashtbl.iter add_method cd.methods","\t\t| _ -> ()","","\tin let add_heritage_structure class_name class_descriptor =","\t\tmatch class_descriptor with","\t\t| ClassDescriptor cd -> ","\t\t\tif Hashtbl.find table_done class_name <> true then begin","\t\t\t\tlet parent_descriptor = Hashtbl.find classes_descriptors cd.parent","\t\t\t\tin","\t\t\t\tHashtbl.replace table_done cd.name true;","\t\t\t\tmerge_attrs parent_descriptor cd;","\t\t\t\tmerge_methods parent_descriptor cd","\t\t\tend","\t\t\t(* The descriptor for that class has already been checked, return it as is. *)","\t\t| _ -> ()","\tin","\tHashtbl.iter (fun k _ -> Hashtbl.add table_done k false) classes_descriptors;","\tHashtbl.iter add_heritage_structure classes_descriptors","","","(* This function builds the methods and attributes descriptors of a class *)","(* class_descriptor is the class descriptor to which we add attributs and methods descriptors. *)","(* methods_table is the global methods' table. *)","(* l_methods_attrs is the list of typed methods and attributs defined in the class. *)","(* This function returns Unit, since it only modifies the two first parameters. *)","let rec build_attrs_and_methods_descriptors class_descriptor methods_table l_methods_attrs = ","","\tlet _add_method_to_descriptor m = ","\t\t(* Build a method descriptor and add it to the global methods table. Also, add a link to the method","\t\tin the list of methods of the current class descriptor. It returns Unit *)","\t\tlet build_method_descriptor m_name args m_expr m_static =","\t\t\tlet m_short_id = build_short_method_identifier m_name (params_types args)","\t\t\tin let m_id = class_descriptor.name ^ \"[\" ^ m_short_id ^ \"]\"","\t\t\tin ","\t\t\tHashtbl.add methods_table m_id ","\t\t\t\t{","\t\t\t\t\tstatic=m_static;","\t\t\t\t\tcore=m_expr;","\t\t\t\t\targs_names=params_names args;","\t\t\t\t};","\t\t\tHashtbl.add class_descriptor.methods m_short_id m_id","\t\tin match Located.elem_of m with ","\t\t\t| TypedMethod(r, n, args, e, t) -> build_method_descriptor (Located.elem_of n) args e false ","\t\t\t| TypedStaticMethod(r, n, args, e, t) -> build_method_descriptor (Located.elem_of n) args e true ","","\tand _add_attr_to_descriptor n static e =","\t\tHashtbl.add class_descriptor.attributes (Located.elem_of n) {default=e; static=static;}","","\tin match l_methods_attrs with","\t| [] -> ()","\t| elem::q -> (match (Located.elem_of elem) with ","\t\t\t| TypedMethod _ | TypedStaticMethod _ -> _add_method_to_descriptor elem;","\t\t\t| TypedAttr(_, n, t) -> _add_attr_to_descriptor n false (Located.mk_elem TypedNull (Located.loc_of elem))","\t\t\t| TypedAttrWithValue(_, n, e, t) -> _add_attr_to_descriptor n false e","\t\t\t| TypedStaticAttr(_, n, t) -> _add_attr_to_descriptor n true (Located.mk_elem TypedNull (Located.loc_of elem))","\t\t\t| TypedStaticAttrWithValue(_, n, e, t) -> _add_attr_to_descriptor n true e","\t\t);","\t\tbuild_attrs_and_methods_descriptors class_descriptor methods_table q","","","","(* Create new classes descriptors, but without methods and attributes for the moment. *)","let rec build_descriptors_1 classes_descriptors methods_table tree =","\tmatch tree with","\t| [] -> ()","\t| t::q -> (match Located.elem_of t with ","\t\t\t| TypedClassdef (n, l) ->","\t\t\t\tlet adv_class_descriptor = {","\t\t\t\t\tname=Located.elem_of n;","\t\t\t\t\tparent=\"Object\";","\t\t\t\t\tattributes=Hashtbl.create 10;","\t\t\t\t\tmethods=Hashtbl.create 10;","\t\t\t\t}","\t\t\t\tin ","\t\t\t\tHashtbl.add classes_descriptors (Located.elem_of n) (ClassDescriptor(adv_class_descriptor));","\t\t\t\tbuild_attrs_and_methods_descriptors adv_class_descriptor methods_table l","","\t\t\t| TypedClassdefWithParent (n, p, l) -> ","\t\t\t\tlet adv_class_descriptor = {","\t\t\t\t\tname=Located.elem_of n;","\t\t\t\t\tparent=string_of_classname (Located.elem_of p);","\t\t\t\t\tattributes=Hashtbl.create 10;","\t\t\t\t\tmethods=Hashtbl.create 10;","\t\t\t\t}","\t\t\t\tin ","\t\t\t\tHashtbl.add classes_descriptors (Located.elem_of n) (ClassDescriptor(adv_class_descriptor));","\t\t\t\tbuild_attrs_and_methods_descriptors adv_class_descriptor methods_table l","","\t\t\t| _ -> ()","\t\t);","\t\tbuild_descriptors_1 classes_descriptors methods_table q","","","let compile tree = ","\tlet classes_descriptors = Hashtbl.create 10","\tand methods_table = Hashtbl.create 30","\tin","\tbuild_basic_classes_descriptors classes_descriptors;","\tbuild_descriptors_1 classes_descriptors methods_table tree;","\tadd_heritage_structures classes_descriptors methods_table;","","\tclasses_descriptors, methods_table"]}]}],[{"group":"doc","deltas":[{"start":{"row":0,"column":0},"end":{"row":43,"column":42},"action":"insert","lines":["open Hashtbl","","open TypedStructure","","","type attribute_descriptor = {","\tstatic: bool;","\tdefault: typed_expr Located.t;","}","","type method_descriptor = {","\tstatic: bool;","\targs_names: string list;","\tcore: typed_expr Located.t;","}","","(* ","\tClass descriptor, with:","\tname: name of the class","\tattributes: hash table with keys: name of an attribute, values: typed expression of the default values","\tmethods: Hash table with keys: id of a method without the class, values: keys from the global methods table","*)","type advanced_class_descriptor = {","\tname: string;\t(* \tName is redundant since a class descriptor is the value of a hash table, ","\t\t\t\t\t\twhich keys are the names of the classes *)","\tparent: string;\t(* We keep this information for casting, at least. *)","\tattributes: (string, attribute_descriptor) Hashtbl.t;","\tmethods: (string, string) Hashtbl.t;","}","","type class_descriptor =","\t| ClassDescriptor of advanced_class_descriptor","\t| ObjectClass","\t| IntClass","\t| BooleanClass","\t| StringClass","","let build_short_method_identifier (m_name: string) (args: string list) =","\tlet rec args_str = function","\t\t| [] -> \"\"","\t\t| [t] -> t","\t\t| t::q -> t ^ \",\" ^ (args_str q)","\t(* Short Identifier looks like: m(Int,Boolean) *)","\tin (m_name ^ \"(\" ^ (args_str args) ^ \")\")"]}]}],[{"group":"doc","deltas":[{"start":{"row":2,"column":5},"end":{"row":2,"column":19},"action":"remove","lines":["TypedStructure"]},{"start":{"row":2,"column":5},"end":{"row":2,"column":6},"action":"insert","lines":["T"]}]}],[{"group":"doc","deltas":[{"start":{"row":2,"column":6},"end":{"row":2,"column":7},"action":"insert","lines":["y"]}]}],[{"group":"doc","deltas":[{"start":{"row":2,"column":7},"end":{"row":2,"column":8},"action":"insert","lines":["p"]}]}],[{"group":"doc","deltas":[{"start":{"row":2,"column":8},"end":{"row":2,"column":9},"action":"insert","lines":["e"]}]}]]},"ace":{"folds":[],"scrolltop":92.8333740234375,"scrollleft":0,"selection":{"start":{"row":21,"column":2},"end":{"row":21,"column":2},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":5,"state":"start","mode":"ace/mode/ocaml"}},"timestamp":1425504268000,"hash":"95fc4ca6fa3798e254489cc779cd6485e149b168"}